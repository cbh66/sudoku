/* Sudoku Solver v2.0
 *   A program to solve Sudoku puzzles.  Provide it with input from std input
 *   in the expected format:
 *     Inputs are listed from left to right, top to bottom (as one would draw
 *     them) with a space between each box, and a  single dash ('-')
 *     representing unknowns.
 *
 *   By Colin Hamilton
 *   Created Feb 6, 2014
 *   Last modified Mar 7, 2015
 */

/*
   TO DO:
"X-wing" rule.  Look for four boxes forming the corners of a square, where
    each box has two possibilities, one of which is shared by them all.
    That shared possibility can be eliminated from elsewhere in the rows and
    columns generated by that box (because it must occur in two of the corners)
    We examine a case for rows, columns are similar:

    For i from 1 to 9:
        For each row in the grid:
            If this row has two possibilities for i, make those squares the
                upper left and right squares of the box.
            Look for another row with two possibilities for i, whose squares
                are in the same columns as the previous step.  Make these
                the lower left and right squares of the box
                If all of those exist, eliminate i from the columns
                    generated by the square

"Swordfish": more generalized.  Examine the case for columns (rows are similar)
    Look for columns where i occurs as a possibility in exactly two places.
    If there are columns for which these squares overlap in their rows,
    eliminate i as a possibility from each of those rows.

    For i from 1 to 9:
        Generate a list of columns for which i occurs as a possibility twice.
        For each permutation of this list of columns:
            Take the union of the rows involved in the columns.
            If the number of rows equals the number of columns:
                Eliminate i as a possibility from each of the rows in the union

Hypothetical - last resort, should only be needed for super-hard puzzles.
    Essentially, test each possibility for the unknown, and continue solving
    as if that were fact.  If this results in an inconsistent board, backtrack
    and eliminate it as a possibility.
 */

#include <iostream>
#include "sudoku.h"
#include "consistency.h"
#include "solve.h"
using namespace std;

bool read(int board[][SIZE]);
void print(int board[][SIZE]);
void solve(int board[][SIZE]);
void solveAll(Guess board[][SIZE]);
void setNum(Guess *square, unsigned num);
int numGuesses(Guess board[][SIZE]);
int numCertain(Guess board[][SIZE]);
void printGuesses(Guess board[][SIZE]);

int main()
{
    int board[SIZE][SIZE];

    if (!read(board) || !isPossible(board)) {
        cout << "It is impossible to solve this board." << endl;
        return 1;
    }
    print(board);
    cout << endl;
    solve(board);
    print(board);

    return 0;
}


/* read()
 *  Purpose: Reads the board from std input, storing it in the given 2-D
 *    array, which (having been passed by reference) is overwritten with the
 *    proper values, SENTINEL representing an unknown.
 *  Arguments: the array (which must be at least SIZExSIZE)
 *  Returns: A boolean, normally true, but false if there are too few clues
 *    for the board to be solveable.
 */
bool read(int board[][SIZE])
{
    unsigned i, j, count = 0;
    string x;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            cin >> board[i][j];
            if (cin.fail()) {
                cin.clear();
                board[i][j] = SENTINEL;
            } else {
               ++count;
            }
        }
    }
    return (count >= MIN);
}


/* print()
 *  Purpose: Prints the given board to std output.
 *  Arguments: the board to print (which must be at least SIZExSIZE)
 *  Returns: nothing
 *  Notes: does not modify the array
 */
void print(int board[][SIZE])
{
    unsigned i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            if (j != 0) cout << " ";
            if (board[i][j] == SENTINEL) cout << "-";
            else cout << board[i][j];
        }
        cout << endl;
    }
}


/* solve()
 *   Purpose:  Solves the given board to the extent that it is possible to do
 *     so.
 *   Arguments:  The board to solve.  This is passed by reference and so WILL
 *     BE MODIFIED.
 *   Returns:  Nothing; uses the board parameter to "return" the solved board
 */
void solve(int board[][SIZE])
{
    unsigned i, j, k;
    Guess copy[SIZE][SIZE];
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
	       setNum(&copy[i][j], board[i][j]);
        }
    }

    solveAll(copy);

    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            if (copy[i][j].amt == 1) {
                for (k = 0; k < SIZE; ++k) {
                    if (copy[i][j].possible[k]) break;
                }
                board[i][j] = k + 1;
            }
        }
    }
}


/*  solveAll()
 *  Purpose: Given a board of guesses, eliminates possibilities to solve it.
 *  Parameters: The board, which must be SIZExSIZE.  The array will be modified
 *           as it is solved.
 *  Returns: None.
 *  Notes:   Does not yet work on all inputs.  Will do its best.
 *           Repeats a number of strategies while it can still make progress.
 *           Stops when it can no longer eliminate anything.
 */
void solveAll(Guess board[][SIZE])
{
    int before =  numGuesses(board);
    int after = 0;
    cerr << "Before: " << before << endl;
    printGuesses(board);
    printBoard(board);
    while (before != after) {/*
        elimAllRepeats(board);
        cerr << "Eliminated some repeats: left with " << numGuesses(board)
             << endl;
        printBoard(board);*/
        findUniqueNums(board);
        cerr << "Found some unique numbers: left with " << numGuesses(board)
             << endl;
        printBoard(board);/*
        eliminateGroups(board);
        cerr << "Eliminated some row groups: left with " << numGuesses(board)
             << endl;
        printBoard(board);*/
        eliminatePermutations(board);
        cerr << "Dealt with permutations: left with " << numGuesses(board)
             << endl;
        printBoard(board);

        before = after;
        after = numGuesses(board);
        cerr << "Next: " << after << endl;
    }
}


// For debugging.  Prints the number of possibilities at each square.
void printGuesses(Guess board[][SIZE])
{
    unsigned i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            cout << board[i][j].amt << " ";
        }
        cout << endl;
    }
    cout << endl;
}

