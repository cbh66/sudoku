/* Sudoku Solver v2.0
 *   A program to solve Sudoku puzzles.  Provide it with input from std input
 *   in the expected format:
 *     Inputs are listed from left to right, top to bottom (as one would draw
 *     them) with a space between each box, and a  single dash ('-')
 *     representing unknowns.
 *
 *   By Colin Hamilton
 *   Created Feb 6, 2014
 *   Last modified Mar 7, 2015
 */

/*
   TO DO:
"X-wing" rule.  Look for four boxes forming the corners of a square, where
    each box has two possibilities, one of which is shared by them all.
    That shared possibility can be eliminated from elsewhere in the rows and
    columns generated by that box (because it must occur in two of the corners)
    We examine a case for rows, columns are similar:

    For i from 1 to 9:
        For each row in the grid:
            If this row has two possibilities for i, make those squares the
                upper left and right squares of the box.
            Look for another row with two possibilities for i, whose squares
                are in the same columns as the previous step.  Make these
                the lower left and right squares of the box
                If all of those exist, eliminate i from the columns
                    generated by the square

"Swordfish": more generalized.  Examine the case for columns (rows are similar)
    Look for columns where i occurs as a possibility in exactly two places.
    If there are columns for which these squares overlap in their rows,
    eliminate i as a possibility from each of those rows.

    For i from 1 to 9:
        Generate a list of columns for which i occurs as a possibility twice.
        For each permutation of this list of columns:
            Take the union of the rows involved in the columns.
            If the number of rows equals the number of columns:
                Eliminate i as a possibility from each of the rows in the union

X-Y Wing: Find three squares, each with two possibilities, where the union of
    these possibilities has 3 elements.

Alternate Pair Exclusion: Even more generalized.  You needn't just consider
    rows and columns: blocks can help too.  Ultimately, you look, for each
    number, to find a pair of blocks that have the number and are in the same
    row, column, or block.  You then look to "chain" on to this with more
    squares with this possibility that share a row, column, or block with the
    previous thing in the chain.  Then color the chain alternating red/blue.
    If a row, column, or block has both a red and blue square in it, the number
    can be eliminated from elsewhere in the row, column, or block.

Alternate Pair Deduction: Actually uses the same chain-making as above, but
    after coloring, you look for rows, columns, or blocks, where there are
    two of the same color.  If this is the case, the chosen number must be
    assigned to squares with the other color.

Alternate way of constructing the above chains, probably better:
    Consider pairs of squares in rows, columns, or blocks, where these squares
    are the only ones with the given possibility.  A "strong" chaining can be
    made if elements of two different pairs are linked by being a pair
    themselves in a group.  Then the previous two rules apply.
    But a "weak" pairing is also possible: where squares from different pairs
    share a row/col/group, but are not themselves a pair (another possibility
    somewhere precludes it).  In this case, you must make two separate chains
    and color separately, but can still link the chains by "connecting" the
    colors of the squares that form the link.
    The aim is: if two elements have separate colors, you are saying: if
    squares of one color get the number, squares of the other color cannot
    get it.  If they have the same color, you're saying: if one square of this
    color gets it, ALL squares of this color get it.

Hypothetical - last resort, should only be needed for super-hard puzzles.
    Essentially, test each possibility for the unknown, and continue solving
    as if that were fact.  If this results in an inconsistent board, backtrack
    and eliminate it as a possibility.
 */

#include <iostream>
#include "sudoku.h"
#include "solve.h"
using namespace std;

bool read(int board[][SIZE]);
void print(int board[][SIZE]);
void solve(int board[][SIZE]);
void solveAll(Guess board[][SIZE]);
void setNum(Guess *square, unsigned num);
int numGuesses(Guess board[][SIZE]);
int numCertain(Guess board[][SIZE]);
void printGuesses(Guess board[][SIZE]);

int main()
{
    int board[SIZE][SIZE];

    if (!read(board) || !isPossible(board)) {
        cout << "It is impossible to solve this board." << endl;
        return 1;
    }
    print(board);
    cout << endl;
    solve(board);
    print(board);

    return 0;
}


/* read()
 *  Purpose: Reads the board from std input, storing it in the given 2-D
 *    array, which (having been passed by reference) is overwritten with the
 *    proper values, SENTINEL representing an unknown.
 *  Arguments: the array (which must be at least SIZExSIZE)
 *  Returns: A boolean, normally true, but false if there are too few clues
 *    for the board to be solveable.
 */
bool read(int board[][SIZE])
{
    unsigned i, j, count = 0;
    string x;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            cin >> board[i][j];
            if (cin.fail()) {
                cin.clear();
                board[i][j] = SENTINEL;
            } else {
               ++count;
            }
        }
    }
    return (count >= MIN);
}


/* print()
 *  Purpose: Prints the given board to std output.
 *  Arguments: the board to print (which must be at least SIZExSIZE)
 *  Returns: nothing
 *  Notes: does not modify the array
 */
void print(int board[][SIZE])
{
    unsigned i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            if (j != 0) cout << " ";
            if (board[i][j] == SENTINEL) cout << "-";
            else cout << board[i][j];
        }
        cout << endl;
    }
}


/* solve()
 *   Purpose:  Solves the given board to the extent that it is possible to do
 *     so.
 *   Arguments:  The board to solve.  This is passed by reference and so WILL
 *     BE MODIFIED.
 *   Returns:  Nothing; uses the board parameter to "return" the solved board
 */
void solve(int board[][SIZE])
{
    unsigned i, j, k;
    Guess copy[SIZE][SIZE];
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
	       setNum(&copy[i][j], board[i][j]);
        }
    }

    solveAll(copy);

    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            if (copy[i][j].amt == 1) {
                for (k = 0; k < SIZE; ++k) {
                    if (copy[i][j].possible[k]) break;
                }
                board[i][j] = k + 1;
            }
        }
    }
}


/*  solveAll()
 *  Purpose: Given a board of guesses, eliminates possibilities to solve it.
 *  Parameters: The board, which must be SIZExSIZE.  The array will be modified
 *           as it is solved.
 *  Returns: None.
 *  Notes:   Does not yet work on all inputs.  Will do its best.
 *           Repeats a number of strategies while it can still make progress.
 *           Stops when it can no longer eliminate anything.
 */
void solveAll(Guess board[][SIZE])
{
    int before =  numGuesses(board);
    int after = 0;
    cerr << "Before: " << before << endl;
    printGuesses(board);
    printBoard(board);
    while (before != after) {
        eliminatePermutations(board);
        cerr << "Examined subsets: left with " << numGuesses(board)
             << endl;
        printBoard(board);

        findUniqueNums(board);
        cerr << "Found some unique numbers: left with " << numGuesses(board)
             << endl;
        printBoard(board);

        eliminateGroups(board);
        cerr << "Eliminated subgroup intersections: left with "
             << numGuesses(board) << endl;
        printBoard(board);

        before = after;
        after = numGuesses(board);
        cerr << "Next: " << after << endl;
    }
}


// For debugging.  Prints the number of possibilities at each square.
void printGuesses(Guess board[][SIZE])
{
    unsigned i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            cout << board[i][j].amt << " ";
        }
        cout << endl;
    }
    cout << endl;
}

